{"ast":null,"code":"import{Streamlit,StreamlitComponentBase,withStreamlitConnection}from\"streamlit-component-lib\";import React from\"react\";import ReactFlow,{Controls,Background,MiniMap,applyEdgeChanges,applyNodeChanges,ConnectionMode,ControlButton}from'reactflow';import'reactflow/dist/style.css';import MultiPurposeNode from'./MultiPurposeNode';// Import the custom node\nimport{jsxs as _jsxs}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";const nodeTypes={multiPurposeNode:MultiPurposeNode};/**\r\n   * This is a React-based component template. The `render()` function is called\r\n   * automatically when your component should be re-rendered.\r\n   */class SL_ReactFlow extends StreamlitComponentBase{constructor(props){super(props);this.onNodeClick=(_,node)=>{this.setState({selectedNodeId:node.id});};this.onEdgeClick=(_,edge)=>{this.setState({selectedEdgeId:edge.id});};this.state={numClicks:0,isFocused:false,nodes:[],edges:[],lastNumClicks:0,selectedNodeId:null,selectedEdgeId:null};this.addEdge=(sourceId,targetId)=>{const newEdge={id:\"e-\".concat(this.state.edges.length+1),source:sourceId,target:targetId};this.setState(prevState=>({edges:[...prevState.edges,newEdge]}));};this.onConnect=params=>{this.setState(prevState=>({edges:[...prevState.edges,{id:\"e\".concat(prevState.edges.length),...params}]}));};this.onNodesChange=changes=>{this.setState(state=>({nodes:applyNodeChanges(changes,state.nodes)// Type assertion here\n}));};this.onEdgesChange=changes=>{this.setState(state=>({edges:applyEdgeChanges(changes,state.edges)}));};this.deleteSelectedNode=()=>{this.setState(prevState=>({nodes:prevState.nodes.filter(n=>n.id!==this.state.selectedNodeId),edges:prevState.edges.filter(e=>e.source!==this.state.selectedNodeId&&e.target!==this.state.selectedNodeId),selectedNodeId:null// Reset selected node ID\n}));};this.deleteSelectedEdge=()=>{if(!this.state.selectedEdgeId)return;this.setState(prevState=>({edges:prevState.edges.filter(edge=>edge.id!==prevState.selectedEdgeId),selectedEdgeId:null// Reset selected edge ID\n}));};this.deleteSelectedElement=()=>{if(this.state.selectedNodeId){this.setState(prevState=>({nodes:prevState.nodes.filter(node=>node.id!==prevState.selectedNodeId),edges:prevState.edges.filter(e=>e.source!==this.state.selectedNodeId&&e.target!==this.state.selectedNodeId),selectedNodeId:null// Reset selected node ID\n}));}else if(this.state.selectedEdgeId){this.setState(prevState=>({edges:prevState.edges.filter(edge=>edge.id!==prevState.selectedEdgeId),selectedEdgeId:null// Reset selected edge ID\n}));}};this.clearCanvas=()=>{this.setState({nodes:[],edges:[]});};this.saveCanvas=()=>{Streamlit.setComponentValue({nodes:this.state.nodes,edges:this.state.edges});};this.loadCanvas=(nodes,edges)=>{this.setState({nodes,edges});};this.streamlitButtonHandler=()=>{const{numClicks}=this.props.args;const{lastNumClicks}=this.state;const{lastClickButton}=this.props.args;const{canvas}=this.props.args;if(numClicks!==lastNumClicks){this.updateLastNumClicksIfNeeded();// Update lastNumClicks in state\nif(lastClickButton==='Add Node'){this.addNode(this.props.args[\"label\"]||\"Node \".concat(this.state.nodes.length+1));}else if(lastClickButton==='Load Canvas'){this.loadCanvas(canvas.nodes,canvas.edges);}}};this.render=()=>{// Arguments that are passed to the plugin in Python are accessible\n// via `this.props.args`. Here, we access the \"name\" arg.\nconst name=this.props.args[\"name\"];const canvasStyle=this.props.args[\"canvasStyle\"]||{height:1000,width:'100vw'};// Streamlit sends us a theme object via props that we can use to ensure\n// that our component has visuals that match the active theme in a\n// streamlit app.\nconst{theme}=this.props;const style={};// Maintain compatibility with older versions of Streamlit that don't send\n// a theme object.\nif(theme){// Use the theme object to style our button border. Alternatively, the\n// theme style is defined in CSS vars.\nconst borderStyling=\"1px solid \".concat(this.state.isFocused?theme.primaryColor:\"gray\");style.border=borderStyling;style.outline=borderStyling;}// Show a button and some text. \n// When the button is clicked, we'll increment our \"numClicks\" state\n// variable, and send its new value back to Streamlit, where it'll\n// be available to the Python program.\nthis.streamlitButtonHandler();return/*#__PURE__*/_jsxs(\"div\",{style:canvasStyle,children:[/*#__PURE__*/_jsxs(\"h3\",{children:[\" \",name,\" \"]}),/*#__PURE__*/_jsxs(ReactFlow,{connectionMode:ConnectionMode.Loose,nodeTypes:nodeTypes,nodes:this.state.nodes,edges:this.state.edges,onNodesChange:this.onNodesChange,onEdgesChange:this.onEdgesChange,onNodeClick:this.onNodeClick,onEdgeClick:this.onEdgeClick,onConnect:this.onConnect,fitView:true,children:[/*#__PURE__*/_jsx(MiniMap,{nodeStrokeWidth:3,zoomable:true,pannable:true,position:\"bottom-right\"}),/*#__PURE__*/_jsx(Background,{}),/*#__PURE__*/_jsxs(Controls,{showInteractive:false,children:[/*#__PURE__*/_jsxs(ControlButton,{onClick:this.deleteSelectedElement,children:[\" \",/*#__PURE__*/_jsx(\"strong\",{children:\" D \"})]}),/*#__PURE__*/_jsxs(ControlButton,{onClick:this.clearCanvas,children:[\" \",/*#__PURE__*/_jsx(\"strong\",{children:\" W \"})]}),/*#__PURE__*/_jsxs(ControlButton,{onClick:this.saveCanvas,children:[\" \",/*#__PURE__*/_jsx(\"strong\",{children:\" S \"})]})]})]})]});};this.onConnect=this.onConnect.bind(this);this.onNodeClick=this.onNodeClick.bind(this);this.onEdgeClick=this.onEdgeClick.bind(this);this.deleteSelectedNode=this.deleteSelectedNode.bind(this);this.deleteSelectedEdge=this.deleteSelectedEdge.bind(this);this.deleteSelectedElement=this.deleteSelectedElement.bind(this);this.addNode=this.addNode.bind(this);this.clearCanvas=this.clearCanvas.bind(this);this.saveCanvas=this.saveCanvas.bind(this);this.loadCanvas=this.loadCanvas.bind(this);this.streamlitButtonHandler=this.streamlitButtonHandler.bind(this);this.updateLastNumClicksIfNeeded=this.updateLastNumClicksIfNeeded.bind(this);this.onNodesChange=this.onNodesChange.bind(this);this.onEdgesChange=this.onEdgesChange.bind(this);}addNode(label){// Define a new node with the CustomNode structure\nconst newNode={id:\"node-\".concat(this.state.nodes.length+1),// Use the custom node type\ntype:'multiPurposeNode',position:{x:Math.random()*250,y:Math.random()*250},data:{label}};// Update the state in a type-safe manner\nthis.setState(prevState=>({nodes:[...prevState.nodes,newNode]}),()=>{// This callback is executed after the state has been updated.\n});}updateLastNumClicksIfNeeded(){const{numClicks}=this.props.args;// Only update if numClicks has actually changed\nif(numClicks!==this.state.lastNumClicks){this.setState({lastNumClicks:numClicks});}}}// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(SL_ReactFlow);","map":{"version":3,"names":["Streamlit","StreamlitComponentBase","withStreamlitConnection","React","ReactFlow","Controls","Background","MiniMap","applyEdgeChanges","applyNodeChanges","ConnectionMode","ControlButton","MultiPurposeNode","jsxs","_jsxs","jsx","_jsx","nodeTypes","multiPurposeNode","SL_ReactFlow","constructor","props","onNodeClick","_","node","setState","selectedNodeId","id","onEdgeClick","edge","selectedEdgeId","state","numClicks","isFocused","nodes","edges","lastNumClicks","addEdge","sourceId","targetId","newEdge","concat","length","source","target","prevState","onConnect","params","onNodesChange","changes","onEdgesChange","deleteSelectedNode","filter","n","e","deleteSelectedEdge","deleteSelectedElement","clearCanvas","saveCanvas","setComponentValue","loadCanvas","streamlitButtonHandler","args","lastClickButton","canvas","updateLastNumClicksIfNeeded","addNode","render","name","canvasStyle","height","width","theme","style","borderStyling","primaryColor","border","outline","children","connectionMode","Loose","fitView","nodeStrokeWidth","zoomable","pannable","position","showInteractive","onClick","bind","label","newNode","type","x","Math","random","y","data"],"sources":["H:/streamlit_mindmap/build/SL_ReactFlow/frontend/src/SL_ReactFlow.tsx"],"sourcesContent":["import {\r\n    Streamlit,\r\n    StreamlitComponentBase,\r\n    withStreamlitConnection,\r\n  } from \"streamlit-component-lib\"\r\n  import React, { ReactNode} from \"react\"\r\n  import ReactFlow, { Controls, Background ,MiniMap, Edge,applyEdgeChanges, applyNodeChanges,ConnectionMode,ControlButton} from 'reactflow';\r\n  import 'reactflow/dist/style.css';\r\n  import MultiPurposeNode from './MultiPurposeNode'; // Import the custom node\r\n  \r\n  \r\n  const nodeTypes = { multiPurposeNode: MultiPurposeNode };\r\n  interface NodeData {\r\n    label: string;\r\n  }\r\n  interface MultiPurposeNode {\r\n    id: string; // A (not so)unique identifier for the node\r\n    type: 'multiPurposeNode'; // Specify the type explicitly if you have a finite set of node types.\r\n    position: { x: number; y: number }; // The initial position of the node\r\n    data: NodeData;\r\n  }\r\n  \r\n  interface State {\r\n    numClicks: number; // Track the number of clicks\r\n    isFocused: boolean; // Track the focus state\r\n    nodes: MultiPurposeNode[]; // Adding nodes to the state\r\n    edges: Edge[]; // Adding edges to the state  \r\n    lastNumClicks : number; // Track the last number of clicks\r\n    selectedNodeId: string | null; // Track the selected node\r\n    selectedEdgeId: string | null; // Track the selected edge\r\n  }\r\n  \r\n  \r\n  \r\n  /**\r\n   * This is a React-based component template. The `render()` function is called\r\n   * automatically when your component should be re-rendered.\r\n   */\r\n  class SL_ReactFlow extends StreamlitComponentBase<State> {\r\n  \r\n    constructor(props: any) {\r\n      super(props);\r\n      this.onConnect = this.onConnect.bind(this); \r\n      this.onNodeClick = this.onNodeClick.bind(this);\r\n      this.onEdgeClick = this.onEdgeClick.bind(this);\r\n      this.deleteSelectedNode = this.deleteSelectedNode.bind(this);\r\n      this.deleteSelectedEdge = this.deleteSelectedEdge.bind(this);\r\n      this.deleteSelectedElement = this.deleteSelectedElement.bind(this);\r\n      this.addNode = this.addNode.bind(this);\r\n      this.clearCanvas = this.clearCanvas.bind(this);\r\n      this.saveCanvas = this.saveCanvas.bind(this);\r\n      this.loadCanvas = this.loadCanvas.bind(this);\r\n      this.streamlitButtonHandler = this.streamlitButtonHandler.bind(this);\r\n      this.updateLastNumClicksIfNeeded = this.updateLastNumClicksIfNeeded.bind(this);\r\n      this.onNodesChange = this.onNodesChange.bind(this);\r\n      this.onEdgesChange = this.onEdgesChange.bind(this);\r\n    }\r\n    onNodeClick = (_:React.MouseEvent, node:any) => {\r\n      this.setState({ selectedNodeId: node.id });\r\n    }\r\n    onEdgeClick = (_:React.MouseEvent, edge:Edge) => {\r\n      this.setState({ selectedEdgeId: edge.id });\r\n    }\r\n    public state : State = { numClicks: 0, \r\n                  isFocused: false,\r\n                  nodes: [],\r\n                  edges: [],\r\n                  lastNumClicks: 0,\r\n                  selectedNodeId: null,\r\n                  selectedEdgeId: null,\r\n                }; \r\n    addNode(label: string) {\r\n                  // Define a new node with the CustomNode structure\r\n                  const newNode: MultiPurposeNode = {\r\n                    id: `node-${this.state.nodes.length + 1}`,\r\n                    // Use the custom node type\r\n                    type: 'multiPurposeNode',\r\n                    position: { x: Math.random() * 250, y: Math.random() * 250   },\r\n                    data: { label },\r\n                  };\r\n                \r\n                  // Update the state in a type-safe manner\r\n                  \r\n                  this.setState(prevState => ({\r\n                    nodes: [...prevState.nodes, newNode],}),() => {\r\n                      // This callback is executed after the state has been updated.\r\n                      \r\n                  });\r\n                  \r\n                  \r\n                }\r\n    \r\n    addEdge = (sourceId: string, targetId: string) => {\r\n                  const newEdge: Edge = {\r\n                    id: `e-${this.state.edges.length + 1}`,\r\n                    source: sourceId,\r\n                    target: targetId,\r\n                  };\r\n                \r\n                  this.setState(prevState => ({\r\n                    edges: [...prevState.edges, newEdge],\r\n                  }));\r\n                }\r\n    onConnect = (params:any) => {      \r\n                  this.setState(prevState => ({\r\n                    edges: [...prevState.edges, { id: `e${prevState.edges.length}`, ...params }],\r\n                  }));\r\n                }\r\n                     \r\n    onNodesChange = (changes:any) => {\r\n                  this.setState((state) => ({\r\n                    nodes: applyNodeChanges(changes, state.nodes) as MultiPurposeNode[], // Type assertion here\r\n                  }));\r\n      \r\n                }\r\n    onEdgesChange = (changes:any) => {\r\n                  this.setState((state) => ({\r\n                    edges: applyEdgeChanges(changes, state.edges),\r\n                  }));\r\n                }\r\n    deleteSelectedNode = () => {\r\n                  this.setState(prevState => ({\r\n                    nodes: prevState.nodes.filter(n => n.id !== this.state.selectedNodeId),\r\n                    edges: prevState.edges.filter(e => e.source !== this.state.selectedNodeId && e.target !== this.state.selectedNodeId),\r\n                    selectedNodeId: null, // Reset selected node ID\r\n                  }));\r\n                }\r\n    deleteSelectedEdge = () => {\r\n                  if (!this.state.selectedEdgeId) return;\r\n                \r\n                  this.setState(prevState => ({\r\n                    edges: prevState.edges.filter(edge => edge.id !== prevState.selectedEdgeId),\r\n                    selectedEdgeId: null, // Reset selected edge ID\r\n                  }));\r\n                }\r\n                \r\n    deleteSelectedElement = () => {\r\n                  if (this.state.selectedNodeId) {\r\n                    this.setState(prevState => ({\r\n                      nodes: prevState.nodes.filter(node => node.id !== prevState.selectedNodeId),\r\n                      edges: prevState.edges.filter(e => e.source !== this.state.selectedNodeId && e.target !== this.state.selectedNodeId),\r\n                      selectedNodeId: null, // Reset selected node ID\r\n                    }));\r\n                  } else if (this.state.selectedEdgeId) {\r\n                    this.setState(prevState => ({\r\n                      edges: prevState.edges.filter(edge => edge.id !== prevState.selectedEdgeId),\r\n                      selectedEdgeId: null, // Reset selected edge ID\r\n                    }));\r\n                  }\r\n                }\r\n    clearCanvas = () => {\r\n                  this.setState({ nodes: [], edges: [] });\r\n                }\r\n    saveCanvas = () => {\r\n        Streamlit.setComponentValue({ nodes: this.state.nodes, edges: this.state.edges });\r\n                }   \r\n    loadCanvas = (nodes: MultiPurposeNode[], edges: Edge[]) => {\r\n                  this.setState({ nodes, edges });  \r\n                }\r\n\r\n    updateLastNumClicksIfNeeded() {\r\n                  const { numClicks } = this.props.args;\r\n                  // Only update if numClicks has actually changed\r\n                  if (numClicks !== this.state.lastNumClicks) {\r\n                    this.setState({ lastNumClicks: numClicks });\r\n                  }\r\n                }\r\n    streamlitButtonHandler = () => {\r\n                  const { numClicks } = this.props.args;\r\n                  const { lastNumClicks } = this.state;\r\n                  const { lastClickButton } = this.props.args;\r\n                  const { canvas } = this.props.args;\r\n                  if (numClicks !== lastNumClicks) {\r\n                      this.updateLastNumClicksIfNeeded(); // Update lastNumClicks in state\r\n                    if (lastClickButton === 'Add Node') {\r\n                      this.addNode(this.props.args[\"label\"] || `Node ${this.state.nodes.length + 1}`);\r\n                    }\r\n                    else if (lastClickButton === 'Load Canvas') {\r\n                      this.loadCanvas(canvas.nodes, canvas.edges);\r\n                    }\r\n                  }\r\n                }        \r\n                    \r\n\r\n    public render = (): ReactNode => {\r\n      // Arguments that are passed to the plugin in Python are accessible\r\n      // via `this.props.args`. Here, we access the \"name\" arg.\r\n      const name = this.props.args[\"name\"]\r\n      const canvasStyle = this.props.args[\"canvasStyle\"] || { height: 1000 ,width : '100vw'};\r\n  \r\n  \r\n      // Streamlit sends us a theme object via props that we can use to ensure\r\n      // that our component has visuals that match the active theme in a\r\n      // streamlit app.\r\n      const { theme } = this.props\r\n      const style: React.CSSProperties = {}\r\n      \r\n  \r\n      // Maintain compatibility with older versions of Streamlit that don't send\r\n      // a theme object.\r\n      if (theme) {\r\n        // Use the theme object to style our button border. Alternatively, the\r\n        // theme style is defined in CSS vars.\r\n        const borderStyling = `1px solid ${\r\n          this.state.isFocused ? theme.primaryColor : \"gray\"\r\n        }`\r\n        style.border = borderStyling\r\n        style.outline = borderStyling\r\n      }\r\n      \r\n      // Show a button and some text. \r\n      // When the button is clicked, we'll increment our \"numClicks\" state\r\n      // variable, and send its new value back to Streamlit, where it'll\r\n      // be available to the Python program.\r\n      this.streamlitButtonHandler();  \r\n      return (\r\n        <div style = {canvasStyle} >\r\n          <h3> {name} </h3>\r\n        <ReactFlow \r\n        connectionMode={ConnectionMode.Loose}\r\n        nodeTypes={nodeTypes}\r\n        nodes={this.state.nodes}\r\n        edges={this.state.edges}\r\n        onNodesChange={this.onNodesChange}\r\n        onEdgesChange={this.onEdgesChange}\r\n        onNodeClick={this.onNodeClick}\r\n        onEdgeClick={this.onEdgeClick}\r\n        onConnect={this.onConnect}\r\n        fitView>\r\n         <MiniMap nodeStrokeWidth={3} zoomable pannable  position = \"bottom-right\"/>\r\n          <Background />\r\n          <Controls showInteractive={false}>\r\n      <ControlButton onClick={this.deleteSelectedElement}> <strong> D </strong>\r\n      </ControlButton>\r\n      <ControlButton onClick={this.clearCanvas}> <strong> W </strong>\r\n      </ControlButton>\r\n      <ControlButton onClick={this.saveCanvas}> <strong> S </strong>\r\n      </ControlButton>\r\n    </Controls>\r\n        </ReactFlow>\r\n      </div>\r\n  \r\n      )\r\n    }\r\n  \r\n  }\r\n  // \"withStreamlitConnection\" is a wrapper function. It bootstraps the\r\n  // connection between your component and the Streamlit app, and handles\r\n  // passing arguments from Python -> Component.\r\n  //\r\n  // You don't need to edit withStreamlitConnection (but you're welcome to!).\r\n  export default withStreamlitConnection(SL_ReactFlow)"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}