{"ast":null,"code":"var _jsxFileName = \"h:\\\\streamlit_mindmap\\\\component-template\\\\template\\\\my_component\\\\frontend\\\\src\\\\MyComponent.tsx\";\nimport { StreamlitComponentBase, withStreamlitConnection } from \"streamlit-component-lib\";\nimport React from \"react\";\nimport ReactFlow, { Controls, Background, applyEdgeChanges, applyNodeChanges } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport MultiPurposeNode from './MultiPurposeNode'; // Import the custom node\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n/**\r\n * This is a React-based component template. The `render()` function is called\r\n * automatically when your component should be re-rendered.\r\n */\nclass MyComponent extends StreamlitComponentBase {\n  constructor(props) {\n    super(props);\n    this.state = {\n      numClicks: 0,\n      isFocused: false,\n      nodes: [\n      // Initialize with a default node or leave empty if not needed\n      {\n        id: '1',\n        position: {\n          x: 250,\n          y: 5\n        },\n        data: {\n          label: 'Initial Node'\n        }\n      }],\n      edges: [],\n      lastNumClicks: 0\n    };\n    this.addEdge = (sourceId, targetId) => {\n      const newEdge = {\n        id: `e-${this.state.edges.length + 1}`,\n        source: sourceId,\n        target: targetId\n        // Add additional properties as needed\n      };\n      this.setState(prevState => ({\n        edges: [...prevState.edges, newEdge]\n      }));\n    };\n    this.onConnect = params => {\n      const newEdge = {\n        id: `e-${this.state.edges.length}`,\n        source: params.source,\n        target: params.target,\n        // Optionally, include sourceHandle and targetHandle if using handles\n        sourceHandle: params.sourceHandle,\n        targetHandle: params.targetHandle\n      };\n      this.setState(prevState => ({\n        edges: [...prevState.edges, newEdge]\n      }));\n    };\n    this.onNodesChange = changes => {\n      this.setState(state => ({\n        nodes: applyNodeChanges(changes, state.nodes)\n      }));\n    };\n    this.onEdgesChange = changes => {\n      this.setState(state => ({\n        edges: applyEdgeChanges(changes, state.edges)\n      }));\n    };\n    this.render = () => {\n      // Arguments that are passed to the plugin in Python are accessible\n      // via `this.props.args`. Here, we access the \"name\" arg.\n\n      const name = this.props.args[\"name\"];\n      const {\n        numClicks\n      } = this.props.args;\n      const {\n        lastNumClicks\n      } = this.state;\n      const flowStyles = {\n        \"width\": '100%',\n        \"height\": 500\n      };\n      const nodeTypes = {\n        multiPurposeNode: MultiPurposeNode\n      };\n\n      // Streamlit sends us a theme object via props that we can use to ensure\n      // that our component has visuals that match the active theme in a\n      // streamlit app.\n      const {\n        theme\n      } = this.props;\n      const style = {};\n\n      // Maintain compatibility with older versions of Streamlit that don't send\n      // a theme object.\n      if (theme) {\n        // Use the theme object to style our button border. Alternatively, the\n        // theme style is defined in CSS vars.\n        const borderStyling = `1px solid ${this.state.isFocused ? theme.primaryColor : \"gray\"}`;\n        style.border = borderStyling;\n        style.outline = borderStyling;\n      }\n      if (numClicks !== lastNumClicks) {\n        this.setState({\n          lastNumClicks: numClicks\n        }); // Update lastNumClicks in state\n        this.addNode(this.props.args[\"label\"] || `Node ${this.state.nodes.length + 1}`);\n      }\n\n      // Show a button and some text.\n      // When the button is clicked, we'll increment our \"numClicks\" state\n      // variable, and send its new value back to Streamlit, where it'll\n      // be available to the Python program.\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          height: 1000,\n          width: 1000\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: [\" \", name, \" \"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 141,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(ReactFlow, {\n          nodes: this.state.nodes,\n          nodeTypes: nodeTypes,\n          edges: this.state.edges,\n          onNodesChange: this.onNodesChange,\n          onEdgesChange: this.onEdgesChange,\n          onConnect: this.onConnect,\n          children: [/*#__PURE__*/_jsxDEV(Background, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 150,\n            columnNumber: 9\n          }, this), /*#__PURE__*/_jsxDEV(Controls, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 151,\n            columnNumber: 9\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 142,\n          columnNumber: 7\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 140,\n        columnNumber: 7\n      }, this);\n    };\n    this.onConnect = this.onConnect.bind(this);\n  }\n  addNode(label) {\n    const newNode = {\n      id: `node-${this.state.nodes.length + 1}`,\n      position: {\n        x: Math.random() * 400,\n        y: Math.random() * 400\n      },\n      data: {\n        label\n      }\n    };\n    this.setState(prevState => ({\n      nodes: [...prevState.nodes, newNode]\n    }));\n  }\n}\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default _c = withStreamlitConnection(MyComponent);\nvar _c;\n$RefreshReg$(_c, \"%default%\");","map":{"version":3,"names":["StreamlitComponentBase","withStreamlitConnection","React","ReactFlow","Controls","Background","applyEdgeChanges","applyNodeChanges","MultiPurposeNode","jsxDEV","_jsxDEV","MyComponent","constructor","props","state","numClicks","isFocused","nodes","id","position","x","y","data","label","edges","lastNumClicks","addEdge","sourceId","targetId","newEdge","length","source","target","setState","prevState","onConnect","params","sourceHandle","targetHandle","onNodesChange","changes","onEdgesChange","render","name","args","flowStyles","nodeTypes","multiPurposeNode","theme","style","borderStyling","primaryColor","border","outline","addNode","height","width","children","fileName","_jsxFileName","lineNumber","columnNumber","bind","newNode","Math","random","_c","$RefreshReg$"],"sources":["h:/streamlit_mindmap/component-template/template/my_component/frontend/src/MyComponent.tsx"],"sourcesContent":["import {\r\n  Streamlit,\r\n  StreamlitComponentBase,\r\n  withStreamlitConnection,\r\n} from \"streamlit-component-lib\"\r\nimport React, { ReactNode ,useState,useCallback } from \"react\"\r\nimport ReactFlow, { Controls, Background ,MiniMap, Edge,applyEdgeChanges, applyNodeChanges} from 'reactflow';\r\nimport 'reactflow/dist/style.css';\r\n\r\nimport MultiPurposeNode from './MultiPurposeNode'; // Import the custom node\r\n\r\n\r\ninterface Node {\r\n  id: string;\r\n  type?: string;\r\n  position: { x: number; y: number };\r\n  data: { label: string };  \r\n}\r\n\r\ninterface State {\r\n  numClicks: number;\r\n  isFocused: boolean;\r\n  nodes: Node[]; // Adding nodes to the state\r\n  edges: Edge[]; // Adding edges to the state  \r\n  lastNumClicks : number;\r\n}\r\n\r\n\r\n/**\r\n * This is a React-based component template. The `render()` function is called\r\n * automatically when your component should be re-rendered.\r\n */\r\nclass MyComponent extends StreamlitComponentBase<State> {\r\n  constructor(props: any) {\r\n    super(props);\r\n    this.onConnect = this.onConnect.bind(this);\r\n  }\r\n  public state : State = { numClicks: 0, \r\n                isFocused: false,\r\n                nodes: [\r\n                  // Initialize with a default node or leave empty if not needed\r\n                  {\r\n                    id: '1',\r\n                    position: { x: 250, y: 5 },\r\n                    data: { label: 'Initial Node' },\r\n                  },\r\n                  \r\n                ],\r\n                edges: [],\r\n                lastNumClicks: 0,\r\n              }; \r\n  addNode(label: string) {\r\n                const newNode: Node = {\r\n                  id: `node-${this.state.nodes.length + 1}`,\r\n                  position: { x: Math.random() * 400, y: Math.random() * 400 },\r\n                  data: { label },\r\n                };\r\n              \r\n                this.setState(prevState => ({\r\n                  nodes: [...prevState.nodes, newNode],\r\n                }));\r\n              }\r\n  addEdge = (sourceId: string, targetId: string) => {\r\n                const newEdge: Edge = {\r\n                  id: `e-${this.state.edges.length + 1}`,\r\n                  source: sourceId,\r\n                  target: targetId,\r\n                  // Add additional properties as needed\r\n                };\r\n              \r\n                this.setState(prevState => ({\r\n                  edges: [...prevState.edges, newEdge],\r\n                }));\r\n              }\r\n  onConnect = (params:any) => {\r\n                const newEdge = {\r\n                  id: `e-${this.state.edges.length}`,\r\n                  source: params.source,\r\n                  target: params.target,\r\n                  // Optionally, include sourceHandle and targetHandle if using handles\r\n                  sourceHandle: params.sourceHandle,\r\n                  targetHandle: params.targetHandle,\r\n                };\r\n              \r\n                this.setState(prevState => ({\r\n                  edges: [...prevState.edges, newEdge],\r\n                }));\r\n              }\r\n                   \r\n  onNodesChange = (changes:any) => {\r\n                this.setState((state) => ({\r\n                  nodes: applyNodeChanges(changes, state.nodes),\r\n                }));\r\n              }\r\n  onEdgesChange = (changes:any) => {\r\n                this.setState((state) => ({\r\n                  edges: applyEdgeChanges(changes, state.edges),\r\n                }));\r\n              }\r\n              \r\n  public render = (): ReactNode => {\r\n    // Arguments that are passed to the plugin in Python are accessible\r\n    // via `this.props.args`. Here, we access the \"name\" arg.\r\n    \r\n    const name = this.props.args[\"name\"]\r\n    const { numClicks } = this.props.args;\r\n    const { lastNumClicks } = this.state;\r\n    const flowStyles = {\"width\": '100%', \"height\": 500}\r\n    const nodeTypes = { multiPurposeNode: MultiPurposeNode };\r\n\r\n\r\n    // Streamlit sends us a theme object via props that we can use to ensure\r\n    // that our component has visuals that match the active theme in a\r\n    // streamlit app.\r\n    const { theme } = this.props\r\n    const style: React.CSSProperties = {}\r\n    \r\n\r\n    // Maintain compatibility with older versions of Streamlit that don't send\r\n    // a theme object.\r\n    if (theme) {\r\n      // Use the theme object to style our button border. Alternatively, the\r\n      // theme style is defined in CSS vars.\r\n      const borderStyling = `1px solid ${\r\n        this.state.isFocused ? theme.primaryColor : \"gray\"\r\n      }`\r\n      style.border = borderStyling\r\n      style.outline = borderStyling\r\n    }\r\n    if (numClicks !== lastNumClicks) {\r\n      this.setState({ lastNumClicks: numClicks }); // Update lastNumClicks in state\r\n      this.addNode(this.props.args[\"label\"] || `Node ${this.state.nodes.length + 1}`);\r\n    }\r\n    \r\n    // Show a button and some text.\r\n    // When the button is clicked, we'll increment our \"numClicks\" state\r\n    // variable, and send its new value back to Streamlit, where it'll\r\n    // be available to the Python program.\r\n    return (\r\n      <div style={{ height: 1000 ,width : 1000}}>\r\n        <h3> {name} </h3>\r\n      <ReactFlow nodes={this.state.nodes}\r\n      nodeTypes={nodeTypes}\r\n      edges={this.state.edges}\r\n      onNodesChange={this.onNodesChange}\r\n      onEdgesChange={this.onEdgesChange}\r\n      onConnect={this.onConnect}\r\n      >\r\n      \r\n        <Background />\r\n        <Controls />\r\n      </ReactFlow>\r\n    </div>\r\n\r\n    )\r\n  }\r\n\r\n}\r\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\r\n// connection between your component and the Streamlit app, and handles\r\n// passing arguments from Python -> Component.\r\n//\r\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\r\nexport default withStreamlitConnection(MyComponent)\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}